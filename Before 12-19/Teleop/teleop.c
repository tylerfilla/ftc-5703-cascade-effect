#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     sensorCompass,  sensorI2CHiTechnicCompass)
#pragma config(Motor,  mtr_S1_C1_1,     motorDrive2,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     motorDrive3,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_1,     motorDrive1,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_2,     motorDrive4,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C3_1,     motorConveyor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorElevator, tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servoPitchA,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servoPitchB,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// The Doppler Effect
// FTC #5703

// Teleop Program

#include "teleop.h"
#include "JoystickDriver.c"

// Globals for tracking iteration durations
//int previousIterationDurationQueue[PREVIOUS_ITERATION_DURATION_QUEUE_SIZE];
//float previousIterationDurationQueueAverage;

// Scratch space for holonomic drive algorithm; test points for motor debugging
int motorDrive1Power;
int motorDrive2Power;
int motorDrive3Power;
int motorDrive4Power;

// Maximum drive power at any given time
int drivePowerMax;

// Globals managing drive angle
int driveAngleReference;

// A two-byte state for controller-specific precision modes (0-disabled, 1-enabling, 2-enabled, 3-disabling)
short precisionModeState;

void initialize() {
	// Set initial maximum drive power to default
	drivePowerMax = DRIVE_POWER_MAXIMUM_DEFAULT;
}

int fixAngleRange(int angle) {
	while (angle >= 360) {
		angle -= 360;
	}
	while (angle < 0) {
		angle += 360;
	}
	
	return angle;
}

task main() {
	// Initialize
	initialize();
	
	// Wait for FCS start signal
	waitForStart();
	
	// Set initial drive angles to current conditions
	driveAngleReference = SensorValue[sensorCompass];
	
	// Variables reused between iterations
	float c1J1X;
	float c1J1Y;
	float c1J2X;
	float c1J2Y;
	float c1J1Magnitude;
	float c1J2Magnitude;
	float c1J1Angle;
	float translationAngle;
	
	// Teleop loop
	while (true) {
		// Reset drive motor power globals
		motorDrive1Power = 0;
		motorDrive2Power = 0;
		motorDrive3Power = 0;
		motorDrive4Power = 0;
		
		// Read controller states
		getJoystickSettings(joystick);
		
		// Angle reference button
		if (joy1Btn(CONTROLLER_BUTTON_ANGLE_REFERENCE)) {
			driveAngleReference = SensorValue[sensorCompass];
		}
		
		// Precision mode toggle buttons
		if (joy1Btn(CONTROLLER_1_BUTTON_PRECISION_MODE)) {
			if ((precisionModeState & 0xff00) / 0x100 == 0 || (precisionModeState & 0xff00) / 0x100 == 2) {
				precisionModeState |= 0x100;
			}
		} else {
			if ((precisionModeState & 0xff00) / 0x100 == 1) {
				precisionModeState &= 0xff;
				precisionModeState |= 0x200;
			} else if ((precisionModeState & 0xff00) / 0x100 == 3) {
				precisionModeState &= 0xff;
			}
		}
		if (joy2Btn(CONTROLLER_2_BUTTON_PRECISION_MODE)) {
			if (precisionModeState & 0xff == 0 || precisionModeState & 0xff == 2) {
				precisionModeState |= 0x1;
			}
		} else {
			if (precisionModeState & 0xff == 1) {
				precisionModeState &= 0xff00;
				precisionModeState |= 0x2;
			} else if (precisionModeState & 0xff == 3) {
				precisionModeState &= 0xff00;
			}
		}
		
		// Read and adjust joystick values such that they range from -1 to 1
		c1J1X = (joystick.joy1_x1 + 0.5) / 175.5;
		c1J1Y = (joystick.joy1_y1 + 0.5) / 175.5;
		c1J2X = (joystick.joy1_x2 + 0.5) / 175.5;
		c1J2Y = (joystick.joy1_y2 + 0.5) / 175.5;
		
		// Snap the first joystick to 0, 90, 180, and 270 degrees
		if (abs(c1J1X) <= JOYSTICK_1_SNAP_SIZE) {
			c1J1X = 0.0;
		}
		if (abs(c1J1Y) <= JOYSTICK_1_SNAP_SIZE) {
			c1J1Y = 0.0;
		}
		
		// Calculate magnitudes of joystick vectors
		c1J1Magnitude = sqrt(c1J1X * c1J1X + c1J1Y * c1J1Y);
		c1J2Magnitude = sqrt(c1J2X * c1J2X + c1J2Y * c1J2Y);
		
		// Calculate the angle of the first joystick vector and convert it to degrees
		c1J1Angle = acos(c1J1X / c1J1Magnitude) * 180.0 / PI;
		
		// Correct for first joystick vector angles greater than 180 degrees
		if (c1J1Y < 0.0) {
			c1J1Angle = 360.0 - c1J1Angle;
		}
		
		// Zero the deadband of each joystick
		if (c1J1Magnitude <= JOYSTICK_1_DEADBAND_RADIUS) {
			c1J1X = 0.0;
			c1J1Y = 0.0;
			c1J1Magnitude = 0.0;
			c1J1Angle = 0.0;
		}
		if (c1J2Magnitude <= JOYSTICK_2_DEADBAND_RADIUS) {
			c1J2X = 0.0;
			c1J2Y = 0.0;
			c1J2Magnitude = 0.0;
		}
		
		// Calculate translation angle from first joystick angle
		translationAngle = fixAngleRange(c1J1Angle + (SensorValue[sensorCompass] - driveAngleReference));
		
		// Calculate translation as per our holonomic drive algorithm
		if (translationAngle < 90) {
			motorDrive1Power = (int) (c1J1Magnitude *  drivePowerMax * (translationAngle *  HOLONOMIC_DRIVE_CONSTANT_TRANSLATION - 1));
			motorDrive2Power = (int) (c1J1Magnitude * -drivePowerMax);
			motorDrive3Power = (int) (c1J1Magnitude *  drivePowerMax * (translationAngle * -HOLONOMIC_DRIVE_CONSTANT_TRANSLATION + 1));
			motorDrive4Power = (int) (c1J1Magnitude *  drivePowerMax);
		} else if (translationAngle < 180) {
			motorDrive1Power = (int) (c1J1Magnitude *  drivePowerMax);
			motorDrive2Power = (int) (c1J1Magnitude *  drivePowerMax * (translationAngle *  HOLONOMIC_DRIVE_CONSTANT_TRANSLATION - 3));
			motorDrive3Power = (int) (c1J1Magnitude * -drivePowerMax);
			motorDrive4Power = (int) (c1J1Magnitude *  drivePowerMax * (translationAngle * -HOLONOMIC_DRIVE_CONSTANT_TRANSLATION + 3));
		} else if (translationAngle < 270) {
			motorDrive1Power = (int) (c1J1Magnitude *  drivePowerMax * (translationAngle * -HOLONOMIC_DRIVE_CONSTANT_TRANSLATION + 5));
			motorDrive2Power = (int) (c1J1Magnitude *  drivePowerMax);
			motorDrive3Power = (int) (c1J1Magnitude *  drivePowerMax * (translationAngle *  HOLONOMIC_DRIVE_CONSTANT_TRANSLATION - 5));
			motorDrive4Power = (int) (c1J1Magnitude * -drivePowerMax);
		} else if (translationAngle < 360) {
			motorDrive1Power = (int) (c1J1Magnitude * -drivePowerMax);
			motorDrive2Power = (int) (c1J1Magnitude *  drivePowerMax * (translationAngle * -HOLONOMIC_DRIVE_CONSTANT_TRANSLATION + 7));
			motorDrive3Power = (int) (c1J1Magnitude *  drivePowerMax);
			motorDrive4Power = (int) (c1J1Magnitude *  drivePowerMax * (translationAngle *  HOLONOMIC_DRIVE_CONSTANT_TRANSLATION - 7));
		}
		
		// Calculate rotation as per our holonomic drive algorithm
		motorDrive1Power -= c1J2X * drivePowerMax;
		motorDrive2Power -= c1J2X * drivePowerMax;
		motorDrive3Power -= c1J2X * drivePowerMax;
		motorDrive4Power -= c1J2X * drivePowerMax;
		
		// Balance drive overflows
		if (motorDrive1Power > 100) {
			motorDrive3Power += motorDrive1Power - 100;
		}
		if (motorDrive2Power > 100) {
			motorDrive4Power += motorDrive2Power - 100;
		}
		if (motorDrive3Power > 100) {
			motorDrive1Power += motorDrive3Power - 100;
		}
		if (motorDrive4Power > 100) {
			motorDrive2Power += motorDrive4Power - 100;
		}
		if (motorDrive1Power < -100) {
			motorDrive3Power -= motorDrive1Power + 100;
		}
		if (motorDrive2Power < -100) {
			motorDrive4Power -= motorDrive2Power + 100;
		}
		if (motorDrive3Power < -100) {
			motorDrive1Power -= motorDrive3Power + 100;
		}
		if (motorDrive4Power < -100) {
			motorDrive2Power -= motorDrive4Power + 100;
		}
		
		// Save drive motor power global values to be sent to motor controllers
		motor[motorDrive1] = motorDrive1Power;
		motor[motorDrive2] = motorDrive2Power;
		motor[motorDrive3] = motorDrive3Power;
		motor[motorDrive4] = motorDrive4Power;
	}
}
