#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     sensorCompass,  sensorI2CHiTechnicCompass)
#pragma config(Motor,  mtr_S1_C1_1,     motorDrive2,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     motorDrive3,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_1,     motorDrive1,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_2,     motorDrive4,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C3_1,     motorConveyor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorElevator, tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servoPitchA,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servoPitchB,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// The Doppler Effect
// FTC #5703

// Autonomous Program

#include "gui.h"
#include "autonomous.h"
#include "JoystickDriver.c"

/* Configuration GUI state */

int  configStartDelay;
int  configStartPosition;

bool configAcceptStartDelay;
bool configAcceptStartPosition;

TGuiElement configSpinnerStartDelay;

TGuiElement configRadioButtonStartPositionOnRamp;
TGuiElement configRadioButtonStartPositionOnFloor;

/* Configuration GUI functions */

void showConfigGui() {
	// Erase display
	eraseDisplay();
	
	/* Reset config globals */
	
	configStartDelay = -1;
	configStartPosition = START_POSITION_UNDEFINED;
	
	configAcceptStartDelay = false;
	configAcceptStartPosition = false;
	
	// Start event task
	startTask(configGuiEvent);
	
	/* Start delay screen */
	
	gui_begin();
	
	// Screen title
	TGuiElement textInfoDelay = gui_element_create(GUI_ELEMENT_TEXT);
	gui_property_set(textInfoDelay, GUI_PROPERTY_TEXT_ALIGN, GUI_PROPERTY_TEXT_ALIGN_CENTER);
	gui_property_set(textInfoDelay, GUI_PROPERTY_TEXT_LINE, 1);
	gui_property_set(textInfoDelay, GUI_PROPERTY_TEXT_SIZE, GUI_PROPERTY_TEXT_SIZE_NORMAL);
	gui_property_set_str(textInfoDelay, GUI_PROPERTY_TEXT_TEXT, "Start delay:");
	
	// Start delay time spinner
	configSpinnerStartDelay = gui_element_create(GUI_ELEMENT_SPINNER);
	gui_property_set(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_HEIGHT, 16);
	gui_property_set(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_MAXIMUM, 30);
	gui_property_set(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_MINIMUM, 0);
	gui_property_set(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_POS_X, 25);
	gui_property_set(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_POS_Y, 20);
	gui_property_set(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_STEP, 1);
	gui_property_set_str(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_SUFFIX, " s");
	gui_property_set(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_VALUE, 0);
	gui_property_set(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_WIDTH, 50);
	
	// Accept button
	TGuiElement buttonAcceptStartDelay = gui_element_create(GUI_ELEMENT_BUTTON);
	gui_property_set(buttonAcceptStartDelay, GUI_PROPERTY_BUTTON_HEIGHT, 10);
	gui_property_set(buttonAcceptStartDelay, GUI_PROPERTY_BUTTON_POS_X, 25);
	gui_property_set(buttonAcceptStartDelay, GUI_PROPERTY_BUTTON_POS_Y, 6);
	gui_property_set(buttonAcceptStartDelay, GUI_PROPERTY_BUTTON_SHAPE, GUI_PROPERTY_BUTTON_SHAPE_RECTANGLE);
	gui_property_set_str(buttonAcceptStartDelay, GUI_PROPERTY_BUTTON_TEXT, "Accept");
	gui_property_set(buttonAcceptStartDelay, GUI_PROPERTY_BUTTON_WIDTH, 50);
	
	// Give accept button focus for convenience
	gui_element_focus(buttonAcceptStartDelay);
	
	// Wait for accept button press
	gui_event_register(buttonAcceptStartDelay, GUI_EVENT_BUTTON_PRESS, "start_delay");
	while (!configAcceptStartDelay) {}
	
	gui_end();
	
	/* Start position screen */
	
	gui_begin();
	
	// Screen title
	TGuiElement textInfoStartPosition = gui_element_create(GUI_ELEMENT_TEXT);
	gui_property_set(textInfoStartPosition, GUI_PROPERTY_TEXT_ALIGN, GUI_PROPERTY_TEXT_ALIGN_CENTER);
	gui_property_set(textInfoStartPosition, GUI_PROPERTY_TEXT_LINE, 1);
	gui_property_set(textInfoStartPosition, GUI_PROPERTY_TEXT_SIZE, GUI_PROPERTY_TEXT_SIZE_NORMAL);
	gui_property_set_str(textInfoStartPosition, GUI_PROPERTY_TEXT_TEXT, "Start position:");
	
	// "On ramp" radio button
	configRadioButtonStartPositionOnRamp = gui_element_create(GUI_ELEMENT_BUTTON_RADIO);
	gui_property_set(configRadioButtonStartPositionOnRamp, GUI_PROPERTY_BUTTON_RADIO_CHANNEL, 0);
	gui_property_set(configRadioButtonStartPositionOnRamp, GUI_PROPERTY_BUTTON_RADIO_CHECKED, true);
	gui_property_set(configRadioButtonStartPositionOnRamp, GUI_PROPERTY_BUTTON_RADIO_POS_X, 5);
	gui_property_set(configRadioButtonStartPositionOnRamp, GUI_PROPERTY_BUTTON_RADIO_POS_Y, 34);
	
	// "On ramp" radio button label
	TGuiElement labelStartOnRamp = gui_element_create(GUI_ELEMENT_STRING);
	gui_property_set(labelStartOnRamp, GUI_PROPERTY_STRING_POS_X, 20);
	gui_property_set(labelStartOnRamp, GUI_PROPERTY_STRING_POS_Y, 41);
	gui_property_set(labelStartOnRamp, GUI_PROPERTY_STRING_SIZE, GUI_PROPERTY_STRING_SIZE_NORMAL);
	gui_property_set_str(labelStartOnRamp, GUI_PROPERTY_STRING_TEXT, "On ramp");
	
	// "On floor" radio button
	configRadioButtonStartPositionOnFloor = gui_element_create(GUI_ELEMENT_BUTTON_RADIO);
	gui_property_set(configRadioButtonStartPositionOnFloor, GUI_PROPERTY_BUTTON_RADIO_CHANNEL, 0);
	gui_property_set(configRadioButtonStartPositionOnFloor, GUI_PROPERTY_BUTTON_RADIO_CHECKED, false);
	gui_property_set(configRadioButtonStartPositionOnFloor, GUI_PROPERTY_BUTTON_RADIO_POS_X, 5);
	gui_property_set(configRadioButtonStartPositionOnFloor, GUI_PROPERTY_BUTTON_RADIO_POS_Y, 21);
	
	// "On floor" radio button label
	TGuiElement labelStartOnFloor = gui_element_create(GUI_ELEMENT_STRING);
	gui_property_set(labelStartOnFloor, GUI_PROPERTY_STRING_POS_X, 20);
	gui_property_set(labelStartOnFloor, GUI_PROPERTY_STRING_POS_Y, 28);
	gui_property_set(labelStartOnFloor, GUI_PROPERTY_STRING_SIZE, GUI_PROPERTY_STRING_SIZE_NORMAL);
	gui_property_set_str(labelStartOnFloor, GUI_PROPERTY_STRING_TEXT, "On floor");
	
	// Accept button
	TGuiElement buttonStartPositionAccept = gui_element_create(GUI_ELEMENT_BUTTON);
	gui_property_set(buttonStartPositionAccept, GUI_PROPERTY_BUTTON_HEIGHT, 10);
	gui_property_set(buttonStartPositionAccept, GUI_PROPERTY_BUTTON_POS_X, 25);
	gui_property_set(buttonStartPositionAccept, GUI_PROPERTY_BUTTON_POS_Y, 6);
	gui_property_set(buttonStartPositionAccept, GUI_PROPERTY_BUTTON_SHAPE, GUI_PROPERTY_BUTTON_SHAPE_RECTANGLE);
	gui_property_set_str(buttonStartPositionAccept, GUI_PROPERTY_BUTTON_TEXT, "Accept");
	gui_property_set(buttonStartPositionAccept, GUI_PROPERTY_BUTTON_WIDTH, 50);
	
	// Give accept button focus for convenience
	gui_element_focus(buttonStartPositionAccept);
	
	// Wait for accept button press
	gui_event_register(buttonStartPositionAccept, GUI_EVENT_BUTTON_PRESS, "start_position");
	while (!configAcceptStartPosition) {}
	
	gui_end();
	
	// Stop event task
	stopTask(configGuiEvent);
}

// Event task (receives all registered GUI events)
task configGuiEvent() {
	char event[GUI_NUM_BYTES_PER_EVENT];
	
	while (true) {
		gui_event_get(event);
		
		if (!strcmp(event, "start_delay")) {
			configStartDelay = gui_property_get(configSpinnerStartDelay, GUI_PROPERTY_SPINNER_VALUE);
			configAcceptStartDelay = true;
		} else if (!strcmp(event, "start_position")) {
			if (gui_property_get(configRadioButtonStartPositionOnRamp, GUI_PROPERTY_BUTTON_RADIO_CHECKED)) {
				configStartPosition = START_POSITION_RAMP;
			} else if (gui_property_get(configRadioButtonStartPositionOnFloor, GUI_PROPERTY_BUTTON_RADIO_CHECKED)) {
				configStartPosition = START_POSITION_FLOOR;
			}
			
			configAcceptStartPosition = true;
		}
	}
}

/* Autonomous routine functions */

// Main task (entry point)
task main() {
	// Disable JoystickDriver.c diagnostics screen
	bDisplayDiagnostics = false;
	
	// Configure autonomous session via GUI
	showConfigGui();
	
	// Wait for FCS start signal
	waitForStart();
	
	// Wait for configurable start delay
	wait1Msec(1000 * configStartDelay);
	
	// Run autonomous routine
	autonomousRoutine();
}

void autonomousRoutine() {
	// If starting on ramp, drive off
	if (configStartPosition == START_POSITION_RAMP) {
		driveTranslateDistance(90, 100, 100);
	}
}

/* Drive functions */

// Convenience function for stopping all drive motors
void driveStop() {
	// Stop all drive motors
	motor[motorDrive1] = 0;
	motor[motorDrive2] = 0;
	motor[motorDrive3] = 0;
	motor[motorDrive4] = 0;
}

// Calculates and applies individual drive motor powers that result in the given robot drive angle and power
void driveTranslateStart(int angle, int power) {
	// Calculate, according to our holonomic drive algorithm, the modifications to individual motor powers
	if (angle < 90) {
		// First quadrant (motors 2 and 4 coarse, 1 and 3 fine)
		motor[motorDrive1] += (int) (power * (angle *  HOLONOMIC_DRIVE_CONSTANT - 1));
		motor[motorDrive2] += (int) -power;
		motor[motorDrive3] += (int) (power * (angle * -HOLONOMIC_DRIVE_CONSTANT + 1));
		motor[motorDrive4] += (int) power;
	} else if (angle < 180) {
		// Second quadrant (motors 1 and 3 coarse, 2 and 4 fine)
		motor[motorDrive1] += (int) power;
		motor[motorDrive2] += (int) (power * (angle *  HOLONOMIC_DRIVE_CONSTANT - 3));
		motor[motorDrive3] += (int) -power;
		motor[motorDrive4] += (int) (power * (angle * -HOLONOMIC_DRIVE_CONSTANT + 3));
	} else if (angle < 270) {
		// Third quadrant (motors 2 and 4 coarse, 1 and 3 fine, inverted)
		motor[motorDrive1] += (int) (power * (angle * -HOLONOMIC_DRIVE_CONSTANT + 5));
		motor[motorDrive2] += (int) power;
		motor[motorDrive3] += (int) (power * (angle *  HOLONOMIC_DRIVE_CONSTANT - 5));
		motor[motorDrive4] += (int) -power;
	} else if (angle < 360) {
		// Fourth quadrant (motors 1 and 3 coarse, 2 and 4 fine, inverted)
		motor[motorDrive1] += (int) -power;
		motor[motorDrive2] += (int) (power * (angle * -HOLONOMIC_DRIVE_CONSTANT + 7));
		motor[motorDrive3] += (int) power;
		motor[motorDrive4] += (int) (power * (angle *  HOLONOMIC_DRIVE_CONSTANT - 7));
	}
}

// Calculates and applies individual drive motor powers that result in the given robot drive rotation direction and power
void driveRotateStart(int direction, int power) {
	// Validate input
	if (direction != ROTATE_DIRECTION_CW && direction != ROTATE_DIRECTION_CCW) {
		return;
	}
	
	// Modify motor powers with rotation adjustments
	motor[motorDrive1] += direction * power;
	motor[motorDrive2] += direction * power;
	motor[motorDrive3] += direction * power;
	motor[motorDrive4] += direction * power;
}

// Translates the robot through the given angle at the given power for the given duration
void driveTranslateDuration(int angle, int power, int duration) {
	// Reset encoders
	nMotorEncoder[motorDrive1] = 0;
	nMotorEncoder[motorDrive2] = 0;
	nMotorEncoder[motorDrive3] = 0;
	nMotorEncoder[motorDrive4] = 0;
	
	// Begin translating
	driveTranslateStart(angle, power);
	
	// Wait for duration
	wait1Msec(duration);
	
	// Stop translating
	driveStop();
}

// Translates the robot through the given angle at the given power over the given distance
void driveTranslateDistance(int angle, int power, int distance) {
	// Reset encoders
	nMotorEncoder[motorDrive1] = 0;
	nMotorEncoder[motorDrive2] = 0;
	nMotorEncoder[motorDrive3] = 0;
	nMotorEncoder[motorDrive4] = 0;
	
	// Begin translating
	driveTranslateStart(angle, power);
	
	// Calculate individual motor encoder targets
	int targetMotor1 = motor[motorDrive1] * ((float) distance / (float) power) * ENCODER_1_COUNTS_PER_CM;
	int targetMotor2 = motor[motorDrive2] * ((float) distance / (float) power) * ENCODER_2_COUNTS_PER_CM;
	int targetMotor3 = motor[motorDrive3] * ((float) distance / (float) power) * ENCODER_3_COUNTS_PER_CM;
	int targetMotor4 = motor[motorDrive4] * ((float) distance / (float) power) * ENCODER_4_COUNTS_PER_CM;
	
	// Whether or not each motor has met its encoder target
	bool targetMetMotor1 = false;
	bool targetMetMotor2 = false;
	bool targetMetMotor3 = false;
	bool targetMetMotor4 = false;
	
	// Stop each motor as respective encoder targets are met
	while (!targetMetMotor1 || !targetMetMotor2 || !targetMetMotor3 || !targetMetMotor4) {
		if (!targetMetMotor1 && nMotorEncoder[motorDrive1] >= targetMotor1) {
			motor[motorDrive1] = 0;
			targetMetMotor1 = true;
		}
		if (!targetMetMotor2 && nMotorEncoder[motorDrive2] >= targetMotor2) {
			motor[motorDrive2] = 0;
			targetMetMotor2 = true;
		}
		if (!targetMetMotor3 && nMotorEncoder[motorDrive3] >= targetMotor3) {
			motor[motorDrive3] = 0;
			targetMetMotor3 = true;
		}
		if (!targetMetMotor4 && nMotorEncoder[motorDrive4] >= targetMotor4) {
			motor[motorDrive4] = 0;
			targetMetMotor4 = true;
		}
	}
}

// Rotates the robot in the given direction at the given power for the given duration
void driveRotateDuration(int direction, int power, int duration) {
	// Reset encoders
	nMotorEncoder[motorDrive1] = 0;
	nMotorEncoder[motorDrive2] = 0;
	nMotorEncoder[motorDrive3] = 0;
	nMotorEncoder[motorDrive4] = 0;
	
	// Begin rotating
	driveRotateStart(direction, power);
	
	// Wait for duration
	wait1Msec(duration);
	
	// Stop rotating
	driveStop();
}

// Rotates the robot in the given direction at the given power through the given absolute angle (0 degrees east, 90 degrees north)
void driveRotateAngleAbsolute(int direction, int power, int angle) {
	// Begin rotating
	driveRotateStart(direction, power);
	
	// Wait until target angle is within tolerance
	while (abs(SensorValue[sensorCompass] - wrapAngleDegrees(90 - angle)) > TOLERANCE_DRIVE_ROTATE_ANGLE) {}
	
	// Stop rotating
	driveStop();
}

// Rotates the robot in the given direction at the given power through the given relative angle (positive values counter-clockwise)
void driveRotateAngleRelative(int direction, int power, int angle) {
	// Begin rotating
	driveRotateStart(direction, power);
	
	// Make angle absolute and delagate to driveRotateAngleAbsolute
	driveRotateAngleAbsolute(direction, power, wrapAngleDegrees(wrapAngleDegrees(90 - SensorValue[sensorCompass]) + angle));
	
	// Stop rotating
	driveStop();
}

/* Utility functions */

// Wraps any degree angle into [0, 360)
int wrapAngleDegrees(int angle) {
	// Bring above lower bound
	while (angle < 0) {
		angle += 360;
	}
	
	// Bring below upper bound
	while (angle >= 360) {
		angle -= 360;
	}
	
	return angle;
}
